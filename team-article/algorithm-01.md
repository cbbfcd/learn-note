# 一道算法题引发的思考

题目: 从一个数组中找出 N 个数，其和为 M 的所有可能。

先把题目留在这儿，本文的目的也并不是单单只是让你掌握一些解决这个问题的方法。这个问题在网上有一堆答案：背包问题、穷举、排列组合...

我们先思考，什么是算法？算法的作用和目的？如何设计我们的算法？如何测试/优化我们的算法？复杂度表示？

## 什么是算法

>《算法导论》一书将算法（algorithm）描述为定义良好的计算过程，它取一个或一组值作为输入，并产生一个或一组值作为输出。

计算机主要的单元包括：I/O、CPU、内存...，CPU 负责的功能主要就是解释和执行程序，它能认识的就是一堆 0 1 组成的机器码。

我们敲下的每一行代码都最终被编译成机器码交由 CPU 执行。程序就是指令和数据的集合，所以算法本质就是执行设计的指令集，从输入到产生输出的过程。

算法是抽象的概念，越是抽象的东西越有其清晰的特征：

1. 确定性，算法的每一个步骤都是明确的、可行的，结果可预期的
2. 有穷性，算法要有一个终止条件
3. 输入和输出，算法是用来解决问题的，少不了输入和输出

所以，这里纠正几个误区。

贪婪法、分治法、动态规划法、线性规划法、搜索和枚举（包括穷尽枚举）、极大极小值法、Alpha-beta 剪枝等等，很多人认为这些就是算法了，其实这些只是算法设计范式中一些前人总结出来的模式。

对比设计模式，就是一种抽象的最佳实践范式。其实我们写的任何一个代码片段（包含输入和输出）也可以认为是算法的子集，甚至程序也是算法的一种存在形式而已。

之前看到有人把程序比做水流，从源头顺流而下（顺序执行），也可以分流而下（分支、并发），还可以起个漩涡（递归），这些也都只是算法中的具体的实现/组织方式而已。

算法的领域极其广阔，不要把思维仅仅局限在计算机领域中。

对于计算机行业人员来说，算法无疑就是内功，好比乾坤大挪移。学成之后天下武功皆能快速掌握！

## 算法设计

这一块儿其实是很庞大的知识体系，需要苦练的内功根基！

顺序执行、循环和分支跳转是程序设计的三大基本结构，算法也是程序，千姿百态的算法也是由这三大基础结构构成的。

而算法和数据结构关系紧密，数据结构是算法设计的基础。所以对诸如哈希表、队列、树、图等数据结构有深刻的认识对算法设计事半功倍。

// ...

## 解题

我们回到题目中，开始设计我们的算法！

题干信息很简单，核心问题在于如何从数组中选取 N 个数进行求和运算。

可以化繁为简，假如 N = 2，也就是找出数组中两个数的和为 M 的话，你会怎么做？可能你会想到每次从数组中弹出一个数，然后与余下的每个数相加做判断。

那么 N = 3 呢，N = 10 呢，运算量越来越大，明显之前的方式不可行了。

不妨换一种思路，数组中选取不固定数值 N，我们可以尝试着使用标记的方式，1 - 选取， 0 - 未选取。

假设数组 `const arr = [1, 2, 3, 4]`，对应着每个元素都有标记 0 或者 1，如果 N = 4，需要选择 4 个元素，那么对应的标记就只有一种可能 `1111`，N = 3 就可能是 `1110`，`1101`，`1011`，`0111`(C4取3 -> 4)种可能。

那么我们的问题就抽象为了标记中有几个 `1` 就是代表选取了几个数，再遍历其所有的可能，去判断取的这些数字的和是不是等于 M 即可。

问题就变得简单了。

1. 如何将数组和标记关联

`0101` 这样的数据一眼上去第一反应就是二进制啊！对于 `arr` 来说，有 4 个元素，对应的选择方式就是从 `0000`（N = 0）到 `1111`(N = 4)的所有可能。

而 `1111` 就是 `15` 的二进制，也就是说这所有的可能其实对应的就是 `0 - 15` 中所有数对应的二进制。

这里的问题最终变成了如何从数组长度 `4` -> `0 - 15`，当然是左移运算了！ `1 << 4` 的结果是 `16`。

所以我们可以建立这样一个迭代：

```js
const arr = [1, 2, 3, 4]
let len = arr.length, bit = 1 << len
// 这里忽略了 0 的情况(N = 0)，取值就是 1 - 15
for(let i = 1; i < bit; i++) {
  // ...
}
```

2. 如何从`1110`标记中取出`1`的个数

最简单的方式：

```js
const n = num => num.toString(2).replace(/0/g, '').length
```

这其实也是一道算法常考题。位运算是不需要编译的，肯定最快，我们尝试使用 `&` 运算来解决这个问题。因为 `1 & 1 = 1; 1 & 0 = 0`

也就是说 `15 & 14 => 14` -> `1111 & 1110 => 1110` 消掉了最后的 1，所以建立一个迭代，统计消除的次数就是最终有几个 `1` 了。

```js
const n = num => {
  let count = 0
  while(num) {
    num &= (num - 1)
    count++
  }
  return count
}
```

3. 计算和等于 M

现在我们已经可以把所有的选取可能转变为遍历一个数组，然后通过迭代中每个数对应的二进制有几个 `1` 来确定选取元素的个数了。

那么，需要的最后一层判断就是选取的这些数字和必须等于 M 了。

这里其实就是建立一个映射：`1110` 与 `[1, 2, 3, 4]`，就代表选取了 `2, 3, 4`，然后判断 `2 + 3 + 4` 与 M。

如何建立这个映射关系呢？

我们知道前者 `1110` 其实就是对应的外层遍历中的 `i = 14` 的情况。

再看看数组`[1, 2, 3, 4]` 可以将元素及其位置分别映射为 `1000 0100 0010 0001`。

实现方式也是通过左位移：`1 << inx` inx 为数组的下标。

可能部分对位掩码不熟悉的童鞋会有点晕，解释下：

实质上，这里 1 << j 使用 1 的移位来生成其中仅设置第 j 位的位掩码。

比如：14 其二进制表示 `1110`，代表（从右往左）选取了第 2, 3, 4 位。

那么：

```js
  1110
&
  0001
=
  0000 

  1110
&
  0010
=
  0010 
```

所以：

```js
1 << 0 // 1 -> 0001
1 << 1 // 2 -> 0010
1 << 2 // 4 -> 0100
1 << 3 // 8 -> 1000

// 所以， 1110 对应着 第一位没有选取，那么 1110 & 0001(设置为第一位的位掩码) = 0，如果 i & (1 << inx) !== 0 代表该位被选取了
for(let j = 0; j < arr.length; j++){
  if((i & (1 << j) !== 0) {
    // 代表这个数被选取了，我们做累加求和就行
  }
}
```

所以最终实现：

```js
// 参数依次为目标数组、选取元素数目、目标和
const search = (arr, count, sum) => {
  // 计算某选择情况下有几个 `1`，也就是选择元素的个数
  const n = num => {
    let count = 0
    while(num) {
      num &= (num - 1)
      count++
    }
    return count
  }

  let len = arr.length, bit = 1 << len, res = []
  
  // 遍历所有的选择情况
  for(let i = 1; i < bit; i++){
    // 满足选择的元素个数 === count
    if(n(i) === count){
      let s = 0, temp = []

      // 每一种满足个数为 N 的选择情况下，继续判断满足和为 M 与否
      for(let j = 0; j < len; j++){
        // 建立映射，找出选择位上的元素
        if((i & 1 << j) !== 0) {
          s += arr[j]
          temp.push(arr[j])
        }
      }

      // 如果这种选择情况满足和为 M
      if(s === sum) {
        res.push(temp)
      }
    }
  }

  return res
}
```

## 如何测试

测试主要集中在功能测试、性能测试等。对于功能测试需要写全面的测试案例进行全覆盖的测试，利于我们对写的算法进行查漏补缺，增强鲁棒性。

对于性能测试，除了一些工具之外，我们可以简单的通过如 `window.performance.now()` 进行测试。

总体的原则是尽可能测试多的情况、干净的测试环境（不要混入无关代码）、平均情况等。

```js
// 我们可以写一个很大的数组进行测试
const arr = Array.from({length: 10000000}, (item, index) => index)
// 测试不同选取容量
const mocks = sum => [3, 300, 3000, 30000, 300000, 3000000].map(item => ({count: item, sum }))

let res = []
mocks(3000).forEach((count, sum) => {
  const start = window.performance.now()
  search(arr, count, sum)
  const end = window.performance.now()
  res.push(end - start)
})

```

### 对比

主要收集一些实现方式，基于 jsperf 做一些对比。

// ...

## 复杂度