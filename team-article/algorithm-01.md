<!--**文言文其实是一个很牛逼的压缩算法。**-->

**要造就造最好的轮子，狂想录算法小分队出品，必属精品。**

## 故事的背景

这是一个呆萌炫酷吊炸天的前端算法题，曾经乃至现在也是叱咤风云在各个面试场景中。

可以这样说，有 `90%` 以上的前端工程师不会做这个题目，包括大厂的。这道题涉及的知识点很多，虽然网上也有相关的解答文章，但是在算法小分队的讨论和分析中，一致认为网上的文章太旧了，而且最多就是贴贴代码，写写注释，并没有具体的分析。

所以算法小分队一致决定，重写并且优化这个算法。

## 一道算法题引发的思考

题目: **从一个数组中找出 `N` 个数，其和为 `M` 的所有可能。**

大家可以中断 `5` 分钟想一下。

是不是感受到了一股杀气，好像知道些，但是又无从下手的那种胜利的感觉，嗯...？

机智(鸡贼)的我，选择先把题目留在这儿，我们先去调戏(探讨)一下算法这个妹纸。

<!--本文的目的也并不是单单只是让你掌握一些解决这个问题的方法。这个问题在网上有一堆答案：背包问题、穷举、排列组合...-->

> 为什么妹纸就可以无法无天？

我们先思考一下，什么是妹纸？妹纸的作用和目的是什么？如何设计我们的妹纸？如何测试/优化我们的妹纸？妹纸的复杂度该表示？

好啦，别闹了，赶紧把妹子用算法代替了。。

嗯？我怎么感觉死循环了呢？无限递归切没有终止条件？

![](https://user-gold-cdn.xitu.io/2019/3/6/1694f1dfc0e7c927?w=500&h=362&f=png&s=211636)

## 什么是妹纸

>《算法导论》一书将妹纸（ `algorithm` ）描述为定义良好的计算过程，它取一个或一组值作为输入，并产生一个或一组值作为输出。

行吧，就不继续 `cosplay` 了，能做的我都做了，剩下的就看你们了。大家自行把下面的算法想象成妹纸吧。

> 计算的组成

计算机主要的单元包括：`I/O` 、`CPU` 、内存等，这里我们要介绍的是`CPU`。

`CPU` 负责的功能主要就是解释和执行程序，它能认识的就是一堆 `0` 和 `1`  组成的机器码。

我们敲下的每一行代码最终都被编译成机器码，然后将机器码交给 `CPU` 执行。

> 想一想上面的话，我们可以知道：

**我们所知的程序，其实就是指令和数据的集合，而算法的本质就是执行设计好的指令集，从输入到产生输出的过程。**

> 算法是抽象的概念，但越是抽象的东西，其越具有清晰的特征。特征如下：

1. **确定性：** 算法的每一个步骤都是明确的、可行的、结果可预期的
2. **有穷性：** 算法要有一个终止条件
3. **输入和输出：** 算法是用来解决问题的，少不了输入和输出

<!--所以，这里纠正几个误区。-->

### 大多数人只看见了树，缺未见森林

> 看到这，你可能疑问，为什么这样说？切听我娓娓道来。

列举一些大家经常听到的一些词吧：

递归法、贪婪法、分治法、动态规划法、线性规划法、搜索和枚举（包括穷尽枚举）、极大极小值法、`Alpha-beta` 、剪枝等等。

很多人认为这些就是算法了，但其实这只是算法设计范式中一些前人总结出来的模式而已。

> 我们可以将这种算法层面的模式和平常我们说的设计模式进行对比。

会发现，这就是一种算法抽象的最佳实践范式。其实我们写的任何一个代码片段（包含输入和输出），都可以认为是算法的子集，甚至程序也只是算法的一种存在形式而已。

之前看到有人把程序比做水流，从源头顺流而下（顺序执行），也可以分流而下（分支、并发），还可以起个漩涡（递归），其实这些也都只是算法中具体的实现/组织方式而已。

**算法的领域极其广阔，不要把思维仅仅局限在计算机领域中。**

对于计算机行业人员来说，算法无疑就是内功，就好比乾坤大挪移，学成之后天下武功皆能快速掌握！

## 算法设计

这一块儿其实是很庞大的知识体系，需要苦练的内功根基！

顺序执行、循环和分支跳转是程序设计的三大基本结构，算法也是程序，千姿百态的算法也是由这三大基础结构构成的。

算法和数据结构关系紧密，数据结构是算法设计的基础。所以对诸如哈希表、队列、树、图等数据结构有深刻的认识对算法设计事半功倍。

巴拉巴拉这些主要是抛砖引玉，算法的设计与分析是无上神功的心法口诀，入门要领。无论多么精妙绝伦的算法实现，都是由一些最基础的模型和范式组装起来的。

这里我推荐一个课程：[算法设计与分析 Design and Analysis of Algorithms](https://zh.coursera.org/learn/algorithms)。

TIPS: 如果有好的资源可以留言哦

## 最 `nice` 的解法

### 降维分析，化繁为简
现在，到了最关键的时刻。我们回到题目中，开始设计我们的算法。

题干信息很简单，核心问题在于：

> 如何从数组中选取 `N` 个数进行求和运算。

如何做，这里我们通常且正确的做法，是对问题进行降维分析，并且化繁为简。

> 下面开始降维分析，化繁为简。

假如 `N = 2` ，也就是找出数组中两个数的和为 `M` 的话，你会怎么做？可能你会想到每次从数组中弹出一个数，然后与余下的每个数相加做判断。

那么 `N = 3` 呢，`N = 10` 呢，运算量越来越大，明显之前的方式不可行了。

> 不妨换一种思路

数组中选取不固定数值 `N` ，我们可以尝试着使用标记的方式，`1` 表示选取， `0` 表示未选取。

假设数组 `const arr = [1, 2, 3, 4]`，对应着每个元素都有标记 `0` 或者 `1` ，如果 `N = 4` ，需要选择 `4` 个元素，那么对应的标记就只有一种可能 `1111`，`N = 3` 就可能是 `1110`，`1101`，`1011`，`0111`( `C4取3 -> 4` )种可能。

> 开始抽象

通过上面的层层叙述，我们现在的问题可以抽象为：

**标记中有几个 `1` 就是代表选取了几个数，再遍历其所有的可能，然后去判断取的这些数字的和是不是等于 `M` 即可。**

于是，问题开始变得简单了。

### 如何将数组和标记关联

> `0101` 这样的数据一眼望上去第一反应就是二进制啊

对于 `arr` 来说，有 4 个元素，对应的选择方式就是从 `0000`（ `N = 0` ）到 `1111`( `N = 4` )的所有可能。

而 `1111` 就是 `15` 的二进制，也就是说这所有的可能其实对应的就是 `0 - 15` 中所有数对应的二进制。

> 这里的问题最终变成了如何从数组长度 `4` 推导出 `0 - 15`

当然是左移运算了！ `1 << 4` 的结果是 `16`。

所以我们可以建立这样一个迭代：

```js
const arr = [1, 2, 3, 4]
let len = arr.length, bit = 1 << len

// 这里忽略了 0 的情况(N = 0)，取值就是 1 - 15
for(let i = 1; i < bit; i++) {
  // ...
}
```

<!--### 关于位运算-->

<!--如果对-->


### 如何从 `1110` 标记中取出 `1` 的个数

最简单的方式：

```js
const n = num => num.toString(2).replace(/0/g, '').length
```

这其实也是一道算法常考题，因为位运算是不需要编译的，肯定速度最快。

**PS:** 如果不理解位运算为何会提高性能的同学，可以自行搜索一下位运算。简单点说就是：位运算直接用二进制进行表示，省去了中间过程的各种复杂转换，提高了速度。

> 我们尝试使用 `&` 运算来解决这个问题

首先我们肯定知道 `1 & 1 = 1; 1 & 0 = 0` 这些结论的。所以我们从 `15 & 14 => 14` 可以推导出 `1111 & 1110 => 1110` ，为什么可以这样推导呢，因为  `15` 的二进制就是 `111`` ，`14` 同理。

我们可以看到，通过上面的操作消掉了最后的 `1`。

**所以我们可以建立一个迭代，通过统计消除的次数，就能确定最终有几个 `1` 了。**

代码如下：

```js
const n = num => {
  let count = 0
  while(num) {
    num &= (num - 1)
    count++
  }
  return count
}
```

### 计算和等于 `M`

现在我们已经可以把所有的选取可能转变为遍历一个数组，然后通过迭代数组中的每个数对应的二进制，有几个 `1` 来确定选取元素的个数。

> 那么，现在需要的最后一层判断就是选取的这些数字和必须等于 `M`

这里其实就是建立一个映射：

`1110` 到 `[1, 2, 3, 4]` 的映射，就代表选取了 `2, 3, 4`，然后判断 `2 + 3 + 4` 与 `M` 。

这里可以这样看：`1110` 中的左边第一个 `1` 对应着数组 `[1, 2, 3, 4]` 中的 `1` 。 

> 现在有一个问题，该如何建立这个映射关系呢？

我们知道前者 `1110` 其实就是对应的外层遍历中的 `i = 14` 的情况。

再看看数组`[1, 2, 3, 4]` ，我们可以将元素及其位置分别映射为 `1000 0100 0010 0001`。

实现方式也是通过位运算--左位移来实现：

`1 << inx` ，`inx` 为数组的下标。

#### 位掩码介绍

对 **位掩码** 不熟悉的童鞋会有点晕，这里简单科普下：

实质上，这里的 `1 << j` ，是指使用 `1` 的移位来生成其中仅设置第 `j` 位的位掩码。

比如：`14` 的二进制表示为 `1110`，其代表（从右往左）选取了第 `2` , `3` , `4` 位。

<!--也就是第 `2` , `3` , `4` 位为 `1` 。-->

<!--那么我们通过下面代码进行推导一下。-->

<!--代码如下：-->

那么(下面故意写成上下对应的方式)：
```js
// demo1
  1110
&
  0001
=
  0000 
  
// demo2
  1110
&
  0010
=
  0010 
```

> PS: 通过上面代码，我们可以看到上下对应的 `0` 和 `1` 在进行 `&` 运算以后，得出的结果和在 `js` 中进行相同条件下 `&` 运算的结果相同。

所以：
```js
1 << 0 // 1 -> 0001
1 << 1 // 2 -> 0010
1 << 2 // 4 -> 0100
1 << 3 // 8 -> 1000

// 说白了，就是把左边的值变成二进制形式，然后左移或者右移，超出补0

// 所以， 1110 对应着 第一位没有选取，那么 1110 & 0001(设置为第一位的位掩码) = 0，如果 i & (1 << inx) !== 0 代表该位被选取了
for(let j = 0; j < arr.length; j++){
  if((i & (1 << j) !== 0) {
    // 代表这个数被选取了，我们做累加求和就行
  }
}
```

所以最终实现：

```js
// 参数依次为目标数组、选取元素数目、目标和
const search = (arr, count, sum) => {
  // 计算某选择情况下有几个 `1`，也就是选择元素的个数
  const n = num => {
    let count = 0
    while(num) {
      num &= (num - 1)
      count++
    }
    return count
  }

  let len = arr.length, bit = 1 << len, res = []
  
  // 遍历所有的选择情况
  for(let i = 1; i < bit; i++){
    // 满足选择的元素个数 === count
    if(n(i) === count){
      let s = 0, temp = []

      // 每一种满足个数为 N 的选择情况下，继续判断是否满足 和为 M
      for(let j = 0; j < len; j++){
        // 建立映射，找出选择位上的元素
        if((i & 1 << j) !== 0) {
          s += arr[j]
          temp.push(arr[j])
        }
      }

      // 如果这种选择情况满足和为 M
      if(s === sum) {
        res.push(temp)
      }
    }
  }

  return res
}
```

### 如何测试

这其实也是可以单独写一篇文章的知识点。

测试的种类、方式多种多样，我们将自己想象成一个 `Trouble Maker`，各种为难自己写的算法，然后不断优化自己的代码，这个过程也是有趣极了。

我们主要从两个方向下手：

1. 全方位攻击

其实就是抠脑袋想出一万种情况去折腾自己的代码，也就是所谓的地毯式测试案例轰炸！

```js
// 比如针对上面的算法，可以这样写
export const assert = (desc, condition) => {
  condition = typeof condition === "function" ? condition() : condition;
  console.info(`[Test] %c${desc}`, "color: orange");
  if (!condition) {
    throw new Error(`[Error] %c${desc} failed.`, "color: pink");
  }
  console.info(`[Success] %c${desc} success.`, "color: #198");
};

const mock_a = Array.from({ length: 4 }, (item, index) => index);
const mock_b = Array.from({ length: 6 }, (item, index) => index - 3);
const mock_c = Array.from({ length: 4 }, () => 0);

assert(`正整数情况测试`, () => {
  const res = search(mock_a, 2, 3);
  const lengthTest = res.length === 2;
  const resTest = JSON.stringify(res) === JSON.stringify([[1, 2], [0, 3]]);
  return lengthTest && resTest;
});

assert(`负数情况测试`, () => {
  const res = search(mock_b, 2, 0);
  const lengthTest = res.length === 2;
  const resTest = JSON.stringify(res) === JSON.stringify([[-1, 1], [-2, 2]]);
  return lengthTest && resTest;
});

// ...
```
[完整代码](https://codesandbox.io/s/38pn0jvmr1)，然后可以在控制台看到测试结果：

![kvVxcn.png](https://s2.ax1x.com/2019/03/06/kvVxcn.png)

这样的好处就是让自己的代码能够更鲁棒、更全。

比如，我们如果增加小数的情况，这个算法是有问题的，因为精度误差的问题，这里就可以优化以支持小数。

比如，我们可以增加一个公差参数，使得可以不用绝对相等来取数，增加灵活性。

比如, ...

2. 性能测试

关注的第二个点在于性能，因为如果要将自己的算法付诸生产，稳定的功能表现之外，还要有足够让人咋舌的性能！

谁也不想自己写的代码是拖后腿的原因，这里分享一下我自己的技巧:

通过 `window.performance.now()`，或者是 `console.time()` 我们可以简单的获取到程序执行的时间，虽然这只是片面的参考。

在写这样的测试案例的时候，原则就是只关注自己的测试内容，保持干净、考虑极端情况（比如数组很大很大）、多次测试结果进行分析比对等。

当然你可以使用类似 `jsperf` 之类的工具。一点一点的去扣这些优化点，打磨自己的代码！

通过测试数据可以调整你的算法，但是不要为了性能盲目的进行优化，性能优化其实就是找一个平衡点，原则是足够用就好。

比如上面的算法，我们如果采用空间换时间的优化方式，可以在计算 `1` 个数的 `n` 函数上做一些优化 -- 加个缓存。

然后对比性能：

![kveUz9.png](https://s2.ax1x.com/2019/03/06/kveUz9.png)

[完整的测试案例](https://jsperf.com/acm-perf/1)

### 对比

主要收集一些实现方式，基于 `jsperf` 做一些对比。可以留言补充测试案例哟。

`JSPerf` 测试性能结果如下图：

[![kjjo3F.md.png](https://s2.ax1x.com/2019/03/06/kjjo3F.md.png)](https://imgchr.com/i/kjjo3F)

[完整的测试案例](https://jsperf.com/acm-r/1)

## 总结

这道题很有难度，用到的知识也很多，大致用到了以下这些知识：

1. 二进制已经位运算的知识
2. 剪枝的思想

<!--## 复杂度分类-->

<!--### 算法复杂度-->

<!--![](https://user-gold-cdn.xitu.io/2019/3/6/1694f82d58b77f9c?w=1882&h=1226&f=png&s=205895)-->

## 番外篇--如何判断业务代码的复杂度

大家可能会本能的想到大 **O** 方法啥的，对前端来说，还有一种很有趣的判断复杂度的方法，它叫做 **Tom McCabe** 方法。

该方法很简单，通过计算函数中 **决策点** 的数量来衡量复杂度。下面是一种计算决策点(结合前端)的方法：

1. 从 `1` 开始，一直往下通过函数
2. 一旦遇到 `if while for else` 或者带有循环的高阶函数，比如 `forEach map` 等就加 `1`
3. 给 `case` 语句中的每一种情况都加 `1`

比如下面代码:
```js
function fun(arr, n) {
  let len = arr.length
  for (let i = 0; i < len; i++) {
    if (arr[i] == n) {
        // todo...
    } else {
        // todo...
    }
  }
}
```
按照 **Tom McCabe** 方法来计算复杂度，那么这个 `fun` 函数的决策点数量是 `3` 。知道决策点数量后，怎么知道其度量结果呢？这里有一个数值区间判断：

| 数量区间 | 度量结果 |
| ---- | ----   |
| 0-5 | 这个函数可能还不错 |
| 6-10 | 得想办法简化这个函数了 |
| 10+ | 把这个函数的某一部分拆分成另一个函数并调用他 |

从上面的判断依据可以看出，我上面写的代码，数量是 `3` ，可以称为函数还不错。我个人觉得这个判断方法还是很科学和简单的，可以作为平时写代码时判断函数需不需要重构的一个考虑点，毕竟一个函数，一眼扫去，决策点数量大致就知道是多少了，很好计算。

## 备注

- 文中卖了些呆萌，比如把算法比作妹纸，还望各位妹纸大佬多多海涵，小分队是想卖萌让文章不至于太枯燥。
- 文中难免有错误之处，欢迎在评论区指出，大家一起讨论，学习，进步。
- 这是算法小分队的第一篇输出文章，也见证了小分队的努力和成长。

## 交流

本文算法代码在下图的 `前端算法小分队知识合集` 目录中。

![](https://user-gold-cdn.xitu.io/2019/3/6/1694eedab971ec42?w=900&h=1350&f=png&s=186676)

> `TP` 地址：https://github.com/refactoring-now/

如果觉得不错的话，可以 `star` 鼓励一下。

## 感谢付出的小伙伴

非常感谢算法小分队的成员一起努力攻克了这个题目。

<!--非常感谢算法小分队的成员一起努力攻克了这个题目，这篇文章的第一作者承担了 `80%` 的任务。-->

特此感谢：

<!--嗯，知道我要干什么了吧，开始释放-->

**本文第一作者：小金刚**

> github地址：https://github.com/cbbfcd

> 掘金地址：https://juejin.im/user/593df367128fe1006aecb3cf

以及：

**其他贡献者(只列github账号)：[ godkun, ]**


## 组织

> 本文章由前端狂想录算法小分队出品

掘金是狂想录组织的大本营，后面会持续输出前端各个方面的精品文章。欢迎小伙伴们关注这个冉冉升起的 **前端狂想录** 唯一官方指定的掘金账号。

<!--![](https://user-gold-cdn.xitu.io/2019/3/6/1694ef9d79847a83?w=626&h=1162&f=png&s=166194)-->

> 掘金系列文章也会在 **前端狂想录** 公众号上进行同步


![](https://user-gold-cdn.xitu.io/2019/3/6/1694f8d4ee53244e?w=830&h=518&f=png&s=197857)